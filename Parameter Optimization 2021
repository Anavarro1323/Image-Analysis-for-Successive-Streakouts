tic
currentlap = 0
Finds = 0
pvaluelist = {}
Coordinates = cell(1,10000);


warning('off','all')
%Image Loading and Preprocessing
InputRep = imread('InputRep.jpg');

 Target = table2array(Targets) ; 
 OriginalImage = InputRep;	%Loads image into workspace
 
  BW =  OriginalImage(:,:,2); % the 2 in the the third index for this line can be toggled between 1 and 3 for clearest distinction between colony and background
      ThresholdedImage = imbinarize(BW, 'adaptive','ForegroundPolarity','dark','Sensitivity',0.4);
        parr =NaN([4 4 10]);
     
imshowpair(ThresholdedImage,BW,'montage') % View results of toggle here 

 %False Positive Elimination Set up 
 CC1 = bwconncomp(imcomplement(ThresholdedImage)); %makes a struct array of object information, saved as CC1
InLabMat = labelmatrix(CC1); %turns the CC1 structural array into a label matrix, each row is an object, each column is the label matrix is a 1D-index-of-a-pixel within the object indicated by row
RGBLabMat = label2rgb(InLabMat,'jet','w','shuffle'); %turns the sequential numbering into different colors, for visualization
array1 = cell(CC1.NumObjects,1); %creates a list of spaces that will be populated by either 0 or 1, based on maxpix size. Each row is an object, entry in column 1 will indicate given object is to be deleted




for rangemin = [1:5];
    
for rangemax = [5:10];
  range = [rangemin rangemax];
  
 for Sensitivityloop = [0.95:0.01:1];
sense = Sensitivityloop;
     
for maxpix = [500:100:2000]  
%How Many Laps so far?
currentlap = currentlap + 1 
    
CC1 = bwconncomp(imcomplement(ThresholdedImage)); %makes a struct array of object information, saved as CC1
InLabMat = labelmatrix(CC1);

%%False Positive elimination algorithm
%                                                      X represents object
for x =[1:CC1.NumObjects];                           %fills in array1 with 1 or 0, depending on whether a detected object is larger than the maxpix threshold limit. 
 if length(CC1.PixelIdxList{1,x}) > maxpix;             % compare number of pixels in object to maxpix value
 array1{x,1} = 1;                                       %Array1 is a 2D array [size is #objects = row number, 1 is column number]                                                     
 else array1{x,1} = 0;                                   %If current object has more pixels than maxpix, array1's entry for this object is 1
 end                                                        %Array1 stores whether a given object should be erased. 1 if yes, 2 if 0
 end
 
 for x = [1:CC1.NumObjects];                           %If array1 is 1, delete the object, otherwise leave the object
     if array1{x,1} == 1;
 InLabMat(InLabMat == x) = 0;                         %Delete the object. Within the Label matrix, a row (object) chosen to be deleted will have all of the pixel coordinates turned to 0. 
     end
 end
 FPEresult = label2rgb(InLabMat,'jet','w','shuffle');  

 
%Circle Finding Algorithm
[SampleC,SampleR] = imfindcircles(FPEresult,range,'ObjectPolarity','dark','Sensitivity',sense,'Method','twostage');

% figure;imshow(FPEresult)
% viscircles(SampleC, SampleR, 'EdgeColor', 'b')
 

Target(isnan(Target))=0;
ThisRunAreas = times(pi,power(SampleR,2));
A = padcat(ThisRunAreas,Target);
[h,pvalue] = ttest2(A(:,1),A(:,2));

Pvaluelist(currentlap).pvalue = pvalue


Coordinates(currentlap) = {[rangemin; rangemax; sense; maxpix]}
%LengthEffect = 1/minus(length(Target),length(SampleR));
%pres = times(LengthEffect,pvalue);  %pres gives a "P value" that depends on BOTH the number of colonies detected AND the closeness of the distribution to the ideal
%Or, at least, it's supposed to. I need a statistical test that can account
%for both, because the highest pres value in the 20k calculations does not
%result in a good parameter recomendation. 


%adds resulting p value into the P value array (parr), put into the cell,
%cell P value is put in the parr array depends on the parameters
%parr(rangemin,rangemax,fix(times(maxpixloop,0.2)),fix(times(sense,10))) = pres;





colcount = length(SampleR)

if pvalue < 0.005
    Finds = Finds + 1
    Batch(Finds).lap = currentlap
    Batch(Finds).pval = pvalue
    Batch(Finds).colcount = colcount
end

end 


end

 end
end

%close all

Pvaluecell = struct2cell(Pvaluelist)
Pvaluemat = cell2mat(Pvaluecell)


for k = [1:length(Batch)]
    if Batch(k).colcount == length(Target)
    Ideal = Batch(k).lap
    Index = k
    end
end


RminI= Coordinates{Ideal}(1)
RmaxI= Coordinates{Ideal}(2)
SenseI = Coordinates{Ideal}(3)
MaxpixI = Coordinates{Ideal}(4)

%IdealFPE

%%False Positive elimination algorithm
% 
for x =[1:CC1.NumObjects];                           %fills in array1 with 1 or 0, depending on whether a detected object is larger than the maxpix threshold limit. 
 if length(CC1.PixelIdxList{1,x}) > MaxpixI;
 array1{x,1} = 1;
 else array1{x,1} = 0;
 end
 end
 
 for x = [1:CC1.NumObjects];                           %If array1 is 1, delete the object, otherwise leave the object
     if array1{x,1} == 1;
 InLabMat(InLabMat == x) = 0;
     end
 end
 FPEresultI = label2rgb(InLabMat,'jet','w','shuffle');

 %%%%%%%%%%%%%%%





Irange = [RminI RmaxI]

%Circle Finding Algorithm with Ideal
[IdealC,IdealR] = imfindcircles(FPEresultI,[Irange],'ObjectPolarity','dark', ...;
'Sensitivity',SenseI,'Method','twostage');

A = padcat(times(pi,power(IdealR,2)),Target);

figure;imshow(FPEresultI)
viscircles(IdealC, IdealR, 'EdgeColor', 'b')

figure;imshow(InputRep)
viscircles(IdealC, IdealR, 'EdgeColor', 'b')

clc 
%Declaration of Ideal Parameters
fprintf('ideal Range Minimum is')
RminI
fprintf('ideal Range Maximum is')
RmaxI
%fprintf('ideal max pixel value is')
%Imaxpix
fprintf('ideal max sensitivity is')
SenseI
fprintf('ideal MaxPix value is')
MaxpixI 

save('ParameterWorkspace')
toc

